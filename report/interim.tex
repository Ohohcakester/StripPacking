\documentclass{article}
\usepackage{amsmath}
\usepackage[a4paper]{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsthm}

\begin{document}
\theoremstyle{plain}
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{corr}{Corollary}
\theoremstyle{definition}
\newtheorem{defn}{Definition}
\newtheorem{conj}{Conjecture}
\newtheorem{exmp}{Example}
\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

\author{
Oh Shunhao\\
  \texttt{A0065475X}
  \and
Nguyen Quoc Dat\\
  \texttt{A0116703N}
}
\title{CS4234: 2D Strip Packing - Interim Report}
\date{}

\maketitle

\begin{abstract}
\begin{center}
The 2D Strip Packing problem is concerned with the minimum height of a fixed-width strip needed to pack a set of rectangles into the strip. In this report, we give a brief summary of the current state-of-the art, and experiment with the practical effectiveness of some of the existing algorithms.
\end{center}
\end{abstract}

\section{Problem Definition}
In the Strip Packing problem, we are given an infinitely tall strip, of maximum width $W$, and a set of $n$ rectangles $s_1,s_2,\cdots,s_n$, each represented by a tuple $s_i = (w_i,h_i)$, representing the width and height of each rectangle.\\
\\
The task is to pack all of the $n$ rectangles into the strip, so that none of the rectangles overlap, and such that the total height of the strip is minimised.\\
\\
This problem has many applications in the industry, like in manufacturing, where rectangular pieces need to be cut out of a strip of fixed width, or perhaps in sprite packing for games, where fixed-size sprites can be packed into a single image to minimise the memory footprint of a game.\\

\section{State of the Art}
The decision problem of Strip Packing easily shown to be NP-HARD via a reduction from the partition problem.\\
\\
Assuming $P \neq NP$, there is no absolute polynomial time approximation scheme for Strip Packing. In fact, there is no algorithm with an absolute approximation ratio better than $\frac{3}{2} - \epsilon$ as 1-dimensional bin-packing is a subproblem of strip packing (1-dimensional bin packing is equivalent to strip packing with rectangles of height $1$), and in 1-dimensional bin packing, it is NP-HARD to distinguish whether OPT is $2$ or $3$ due to a reduction from the Partition problem.\\
\\
The current best known absolute approximation algorithm has an approximation ratio of $\frac{5}{3} + \epsilon$ by Harren et. al. \cite{harren1}, which is close to the lower bound of $\frac{3}{2} - \epsilon$. On the other hand, asymptotic approximation algorithms do much better. Simple algorithms like First-Fit Decreasing Height and Split-Fit already achieve asymptotic approximation ratios of $\frac{17}{10}$ and $\frac{3}{2}$ respectively. The best known asymptotic approximation ratio for Strip Packing is $\frac{5}{4}$ by Baker et. al.  \cite{baker1}.\\

\section{Existing algorithms}
Many existing approximation algorithms for 2-D Strip Packing are level-oriented algorithms. Level-oriented algorithms involve packing items into shelves of certain heights. These algorithms include First-Fit Decreasing Height, and Split-Fit.
\subsection{First-Fit Decreasing Height}
\textit{First-Fit Decreasing Height} (FFDH) places the rectangles in decreasing height order one by one on the bottom of the strip. When a rectangle cannot be placed on the bottom the strip, a new shelf is created from the top y-coordinate of the leftmost (tallest) rectangle of the topmost shelf.\\
\\
For a given list $L$ of rectangles, the performance of FFDH is bounded by the following:
\[
	FFDH(L) \leq 1.7 \times OPT(L) + 1
\]
The proof for the approximation ratio of FFDH is based on the proof of the approximation ratio for the First-Fit algorithm for the one-dimensional bin packing problem, which is also asymptotically 1.7-approximate.
\subsection{Split-Fit}
\textit{Split-Fit} (SF) also sorts the rectangles by decreasing height. We find $m \geq 1$, which is the maximum integer such that all given rectangles have width less than or equal to $\frac{1}{m}$. The rectangles are then divided into two sets $L_1$ and $L_2$:
\begin{itemize}
\item $L_1$ contains rectangles with width greater than $\frac{1}{m+1}$.
\item $L_2$ contains rectangles with width less than or equal to $\frac{1}{m+1}$.
\end{itemize}
Then, the rectangles in $L_1$ are packed using FFDH. The resulting shelves produced are then rearranged by width, such that all shelves with width more than $\frac{m+1}{m+2}$ are below shelves with width less than or equal to $\frac{m+1}{m+2}$. This results in a free rectangle $R$ of width $\frac{1}{m+2}$ to the right of the shelves with width less than or equal to $\frac{m+1}{m+2}$.\\
\\
We then proceed to pack rectangles in $L_2$ into R, treating it as a strip of width $\frac{1}{m+2}$. However, if a new shelf is to be created, and it exceeds the height of R, then it is placed on top of the shelves from $L_1$ with width less than or equal to $\frac{m+1}{m+2}$, and thus allows the full width of the original strip. This continues until all rectangles have been packed.\\
\\
The performance of SF is bounded by the value of $m$:
\[
	SF(L) \leq \frac{m+2}{m+1}OPT(L) + 2
\]
In other words, if all rectangles have width less than or equal to one third of the strip width, then $m = 3$, and thus the performance bound for SF is $\frac{5}{4}OPT + 2$. However, in the worst case where $m = 1$ i.e. there exists at least one rectangle with width larger than $\frac{1}{2}$, the approximation ratio for SF is:
\[
	SF(L) \leq \frac{3}{2}OPT(L) + 2
\]
\section{Implemented algorithms}
We have implemented the FFDH and SF algorithms with visualisations. The visualisations for our implementations can be seen in Figures \ref{fig:ffdhrun} and \ref{fig:splitfitrun}.\\
\begin{figure}[ht]
\centering
\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{FFDHrun.png}
  \caption{FFDH Algorithm}
  \label{fig:ffdhrun}
\end{subfigure}%
\begin{subfigure}{.35\textwidth}
  \centering
  \includegraphics[width=.5\linewidth]{SplitFitrun.png}
  \caption{Split-Fit Algorithm}
  \label{fig:splitfitrun}
\end{subfigure}
  \caption{Visualisation for our implementation of FFDH and SF}
  \label{fig:ffdhsfrun}
\end{figure}

\section{Brute Force Algorithm}
We describe an optimal solution for 2-D Strip Packing. The algorithm is based off the Maximal Rectangles (MAXRECT) algorithm \cite{rectanglebinpack}. We begin with a simple result:

\begin{defn}
For any feasible packing of a subset of objects, we call the packing tight if every object cannot be moved leftwards or downwards an infinitesimal amount. (i.e. it is touching another object or a boundary on both its left and bottom sides)
\begin{defn}

\begin{thm}
There exists an optimal solution which is tight.
\end{thm}
This is clear as from any optimal solution, we can always move any object leftwards or downwards without increasing the total height, until no object can be moved leftwards or downwards any further.\\

In the MAXRECT algorithm, we place each object sequentially, to construct a feasible solution, while maintaining that the current placement is tight at each step. When we have placed all rectangles, the total height of the rectangles is noted. An exhaustive search of all tight packings is done, to find the tight packing of minimum height.

\begin{defn}
A Free Rectangle is defined as any rectangle that covers open space. (i.e. it does not intersect any existing object)
\end{defn}

\begin{defn}
A Maximal Free Rectangle (Maximal Rectangle) is a Free Rectangle that is not a subset of any other Free Rectangle.
\end{defn}

To do this, we maintain a list of Maximal Rectangles that represent the possible positions one can place the next object. Each Maximal Rectangle represents an area of open space where objects can be placed. By theorem \ref{thm:blmaxrect} each possible object placement position corresponds to placing the object at the bottom left of some maximal rectangle. This also shows that we are able to construct any tight packing using this method.

\begin{thm}
\label{thm:blmaxrect}
When add a new object $s$ to a currently tight packing $P$, if the new placking is tight, then $s$ is at the bottom left corner of some maximal rectangle in packing $P$.
\end{thm}
\begin{proof}
If the new packing is tight, the new object cannot be moved leftwards or downwards. We can thus construct a free rectangle covering the object exactly. The free rectangle cannot be extended leftwards or downwards as the original object was obstructed in those directions. We can thus extend the width rightwards, then height upwards to the maximum possible to make it maximal.
\end{proof}

We note that to maintain the tightness property of the packing, we will need to additionally check that there newly placed object is touching another object (or boundary) on both its bottom and left sides. If the new object fails this check, we do not consider this possible placement. For example, in Figure \ref{fig:floatingmaxrect}, the new packing is no longer tight, even though the new object has been placed in the bottom left corner of a maximal free rectangle.

\begin{figure}[!h]
  \centering
  \includegraphics[width=.5\linewidth]{FFDHrun.png}
  \caption{THE}
  \label{fig:floatingmaxrect}
\end{figure}

We now explain how we can maintain the list of Maximal Rectangles. At the beginning of the algorithm with an empty packing (no objects), there is exactly one maximal rectangle, which consists of the whole strip. (a free rectangle is allowed to have a height of $\infty$). Whenever a new object is placed, the new object is checked for intersection with each existing maximal rectangle in the list. For each maximal rectangle the object intersects, the maximal rectangle is split into multiple maximal rectangles, as detailed by the 16 cases in figure \ref{fig:maxrectsplitting}. (Note: three of the cases cannot occur.)

\begin{figure}[!h]
  \centering
  \includegraphics[width=.5\linewidth]{FFDHrun.png}
  \caption{The 16 cases for splitting maximal rectangles.}
  \label{fig:maxrectsplitting}
\end{figure}

\begin{thm}
\label{thm:maxrectgeneration}
When placing a new object, every new maximal rectangle generated is a subset of some maximal rectangle in the packing before placing the new object.
\end{thm}
\begin{proof}
Consider any new maximal rectangle $r$ in the new packing. When the newly placed object is removed to obtain the previous packing, $r$ is still a free rectangle in the old packing, meaning it is the subset of some maximal rectangle.
\end{proof}

Theorem \ref{thm:maxrectgeneration} shows that the splitting of maximal rectangles will exhaustively identify all new maximal rectangles. However, we note that not all rectangles generated by splitting will be maximal (Figure \fig{fig:splitbutnotmaxrect}). To check that a rectangle is not maximal, we need to check whether there is an obstruction on each of the sides of the free rectangle that prevents the free rectangle from being expanded further.

\begin{figure}[!h]
  \centering
  \includegraphics[width=.5\linewidth]{FFDHrun.png}
  \caption{A free rectangle resulting from a split that is not a maximal rectangle.}
  \label{fig:splitbutnotmaxrect}
\end{figure}

For efficient checking for the existence of an obstruction, we define the notion of a support as follows:

\begin{dfn}
In a packing $P$, The top/bottom/left/right support of a free rectangle is defined as the set of placed objects directly touching the top/bottom/left/right edges of the free rectangle respectively. Objects touching the free rectangles only at the corners do not count as part of the support.
\begin{dfn}

Thus, a free rectangle is maximal if and only if for each of its four sides, it has either a nonempty support or is touching the boundary of the strip at that side. From theorem \ref{thm:supportinheritance}, we only need to check the support of the parent rectangle (Definition \ref{dfn:parentrectangle}) and the most recently placed object to generate the support of the new free rectangle. If the support on any of the sides is empty, we prune the free rectangle if any only if the support of the parent rectangle on the same side is not empty. (We note that if the support of the parent rectangle on that side is empty, that side must be touching the boundary of the strip as the parent rectangle has not been pruned).

\begin{dfn}
\label{dfn:parentrectangle}
When a maximal rectangle is split to form free rectangles, the parent rectangle of the newly-formed free rectangles is the maximal rectangle it was split from.
\end{dfn}

\begin{thm}
\label{thm:supportinheritance}
When a free rectangle $r$ is split from placing an object $s$ into a maximal rectangle $p$ (the parent rectangle), on each side $L$, the support of $r$ on side $L$ is either $\{s\}$ or a subset of the support of $p$ on side $L$.
\end{thm}
\begin{proof}
This is easy to see, as for each of the cases shown in figure \ref{fig:maxrectsplitting}, each of the newly created free rectangles share three sides with the parent rectangle $p$, and the last side touches the object $s$. The side touching the object $s$ has only $s$ as its support, and the other three sides' supports are subsets of the respective sides' support in the parent rectangle $p$.
\end{proof}

There are two other cases we need to consider for maintaining the support lists of each maximal rectangle correctly. Firstly, for the maximal rectangle created at the start of the algorithm, we can initialise each of its support lists to be empty, as it is touching all four of the boundaries of the strip. Secondly, if a newly-placed object happens to be touching an existing maximal rectangle at a boundary, we need to add the newly-placed object to the support of the maximal rectangle. This check can be done at the same time as when we are checking whether the newly placed object intersects any maximal rectangles.\\

Thus, through this method, we are able to maintain a list of the maximal rectangles at any point of the algorithm. At each node in the search tree, for each unplaced object and for each maximal rectangle, if we can place the object into the maximal rectangle (the object's dimensions fits into the boundaries of the maximal rectangle), we try placing that object into that maximal rectangle. Thus, we have created a brute-force algorithm that searches through all possible tight packings, and thus will be able to find an optimal solution for the 2-D Strip Packing problem.\\

\subsection{Asymptotic Analysis of Running Time}
We let the number of rectangles to be fitted by $n$.\\
We note that the number of maximal rectangles at any point of time is at most $3k$, where $k$ is the number of already placed objects. The number of unplaced objects at this point of time is $n-k$. The branching factor at recursion depth $k$ is thus $3k(n-k)$.\\

At each node, when placing a new rectangle $r$ at recursion depth $k$, we have to check its intersection with each of the $\leq 3k$ maximal rectangles. For each maximal rectangle $k$ that has been split, checking and copying over the support takes $O(k)$ time per rectangle. Thus we have a running time of $O(k^2)$ per node.\\

This makes a total running time of $\displaystyle\sum_{m=0}^{n-1} (\prod_{k=1}^{m} 3(k)(n-k))(k-1)^2$. As the last term of this sum dwarfs the sum of the first $n-1$ terms asymptotically, the running time is $O((\prod_{k=1}^{n-1} 3(k)(n-k))(k-1)^2) = O(3^n(n-1)!(n-1)!(n-1)^2) = O(3^n(n!)^2)$.

\subsection{Pruning Rules}



\subsection{Experimental Results}


XXXXXXXXXX

Currently, we are in the process of implementing a Maximal Rectangles-based exhaustive (exponential) algorithm to solve 2-D Bin Packing, based on the idea that when the rectangles in any optimal packing are pushed towards the bottom-left corner of the strip, the packing becomes a solution that can be found by the maximal-rectangles exhaustive search that is no worse than the optimal solution (because we only push rectangles left and downwards).\\\
\\
With the use of FFDH and SF, we can then derive upper and lower bounds for the exhaustive search, from which we hope to create a branch-and-bound algorithm to solve 2-D Strip Packing.

\begin{thebibliography}{9}
\bibitem{harren1}
  Harren, R., Jansen, K., Pradel, L., van Stee, R.:
  \emph{A (5/3 + $\epsilon$)-Approximation for Strip Packing},
  In: WADS 2011 : Algorithms and Data Structures Symposium

\bibitem{baker1}
  Baker, B.S., Brown, D.J., Katseff, H.P.:
  \emph{A 5/4 algorithm for two-dimensional packing},
  Journal of Algorithms 2(4) (1981) 348–368
\end{thebibliography}

\end{document}